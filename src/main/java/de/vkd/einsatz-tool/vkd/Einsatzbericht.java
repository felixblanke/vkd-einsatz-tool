package de.vkd.einsatz_tool.vkd;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;

import org.apache.poi.hssf.usermodel.DVConstraint;
import org.apache.poi.hssf.usermodel.HSSFDataValidation;
import org.apache.poi.hssf.usermodel.HSSFFont;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.BorderStyle;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.CreationHelper;
import org.apache.poi.ss.usermodel.DateUtil;
import org.apache.poi.ss.usermodel.FormulaEvaluator;
import org.apache.poi.ss.usermodel.HorizontalAlignment;
import org.apache.poi.ss.usermodel.IndexedColors;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.VerticalAlignment;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.ss.util.CellRangeAddressList;
import org.apache.poi.ss.util.CellUtil;



/**
 * @author Felix Blanke
 * Used to create the Excel File.
 */
//TODO: Sortierung der Eingeteilten VK
public class Einsatzbericht {
	private Main m;
	
	private static final float BASE_COLUMN_WIDTH = 11.5f;
	
	//BUSSE PUTZEN BOOL VALS:
	private static final boolean BP_IGNORE_EL 			= true;
	private static final boolean BP_IGNORE_AL 			= true;
	private static final boolean BP_IGNORE_BUS 			= true;
	private static final boolean BP_IGNORE_EINGETEILT 	= true;
	private static final boolean BP_IGNORE_ERSATZ 		= true;
	private static final boolean BP_IGNORE_ZUSAETZLICH 	= true;
	private static final boolean BP_IGNORE_SE 			= true;
	private static final boolean BP_IGNORE_AE 			= true;
	private static final boolean BP_IGNORE_UE 			= false;
	private static final boolean BP_IGNORE_NONE 		= true;
	private static final boolean BP_IGNORE_AUSGETRETEN 	= true;
	private static final boolean BP_IGNORE_KUERZUNG 	= true;
	
	
	//TODO: REPLACE MAGIC NUMBERS
//	private static final int COL_RANK = 1;
//	private static final int COL_NAME = 2;
//	private static final int COL_ATTENDANCE = 4;
//	private static final int COL_REMARK = 5;
//	private static final int COL_EINSATZ_NAME = 1;
//	private static final int COL_EINSATZ_BEGIN = -42;
	/* ... */
	
	private String version;
	private String name; 
	private String remark;
	private List<VK> selectedVK;
	private List<VK> listEL;
	private List<VK> listAL;
	private List<VK> listBus;
	private Date begin;
	private Date end;
	private Date creationOfReport;
	
	private final boolean LOCKCELL = false;
	private final boolean READONLY = false;
	
	/**
	 * Loads an Einsatzbericht from an .xls File. This works only if the Einsatzbericht was generated by this program or created extremely similarly,
	 * because the reading process requires the Einsatzbericht to follow the form of the generated reports strictly.
	 * Also it can only be guaranteed that reports from the current half year can be read due to the database changing.
	 * @param m
	 * @param f
	 * @throws Exception 
	 */
	//TODO: ADD EHEMALIGE TO DATABASE
	//TODO: LET THE USER SWITCH THE DATABASES
	public Einsatzbericht(Main m, File f) throws Exception {
		m.getLogger().log(Level.INFO, "Reading Einsatzbericht from " + f.getAbsolutePath());
		HSSFWorkbook wb = null;
		
		String name, remark;
		Date begin, end;
		List<VK> listEL, listAL, listBus, selectedVK;
		
		try {
			List<VK> cleanDatabase = m.getCleanDatabase();
			listEL = new ArrayList<VK>();
			listAL = new ArrayList<VK>();
			listBus = new ArrayList<VK>();
			selectedVK = new ArrayList<VK>();
			
			FileInputStream fis = new FileInputStream(f);
			wb = new HSSFWorkbook(fis);
			Sheet sheet = wb.getSheet(m.getFramework().getString("SHEET_ONE"));
			Row row = sheet.getRow(5);
	
			name = row.getCell(1).getStringCellValue();
			begin = m.settings.getDateFormat().parse(row.getCell(5).getStringCellValue());
			end = m.settings.getDateFormat().parse(row.getCell(6).getStringCellValue());
		
			row = sheet.getRow(7);
						
			String[] strEL, strAL, strBus;
			
			String cellVal = row.getCell(1).getStringCellValue();
			if(!cellVal.equals(m.getFramework().getString("EMPTY_LIST")))
				strEL = cellVal.split(", ");
			else strEL = new String[0];
			
			cellVal = row.getCell(3).getStringCellValue();
			if(!cellVal.equals(m.getFramework().getString("EMPTY_LIST")))
				strAL = cellVal.split(", ");
			else strAL = new String[0];
			
			cellVal = row.getCell(5).getStringCellValue();
			if(!cellVal.equals(m.getFramework().getString("EMPTY_LIST")))
				strBus = cellVal.split(", ");
			else strBus = new String[0];
			
			int lastCounter = 11;
			
			row = sheet.getRow(11);
			for(int k = 11; !(row = sheet.getRow(k)).getCell(1).getStringCellValue().equals(m.getFramework().getString("SHEET_ONE_KUERZUNG")); k++) {
				lastCounter = k;
				if(lastCounter > 1000)throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "The file does not fit the format.",  row.getRowNum(), 1);
				//justThrowExceptions if anything goes wrong
				String rankStr = row.getCell(1).getStringCellValue();
				String nameStr = row.getCell(2).getStringCellValue();
				if(nameStr.isEmpty() && rankStr.isEmpty())continue;
				else {
					String[] names = nameStr.split(", ");
					String vkStrRepresentation = rankStr.concat(" ").concat(names[0]).concat(" ").concat(names[1]);
					VK vk = m.getVK(vkStrRepresentation, cleanDatabase);
					if(vk == null)throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "VK " + vkStrRepresentation + " not found",  row.getRowNum(), 4);
					if(vk.isSelected()) {
						throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "The VK " + vk.getStringRepresentation() + " has already been loaded",  row.getRowNum(), 2);
					}else {
						vk.setSelected(true);
						
						boolean statusSet = false;
						String status = row.getCell(4).getStringCellValue();
						if(status.equalsIgnoreCase("X") || status.equalsIgnoreCase("--")) {
							boolean hasAttended = status.equalsIgnoreCase("X");
							String[] personalRemark = row.getCell(5).getStringCellValue().split(", ");
							for(String s: personalRemark) {
								if(s.equals(m.getFramework().getString("SHEET_ONE_EL"))) {
									listEL.add(vk);
								}else if(s.equals(m.getFramework().getString("SHEET_ONE_AL"))){
									listAL.add(vk);
								}else if(s.equals(m.getFramework().getString("SHEET_ONE_BUS"))) {
									listBus.add(vk);
//								}else {
//									for(Status tempStatus: Status.values()) {
//										setStatusHelper(vk, s, statusName, status, hasAttended, filePath, row, col)
//									}
//								}
//								if(false) {}
								}else if(s.equals(m.getFramework().getString("SHEET_ONE_SE"))) {
									if(!statusSet)statusSet = true;
									else throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Multiple statuses loaded",  row.getRowNum(), 4);
									if(hasAttended)throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting status and attendance",  row.getRowNum(), 4);
									vk.setStatus(Status.SE);
								}else if(s.equals(m.getFramework().getString("SHEET_ONE_AE"))) {
									if(!statusSet)statusSet = true;
									else throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Multiple statuses loaded",  row.getRowNum(), 4);
									if(hasAttended)throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting status and attendance",  row.getRowNum(), 4);
									vk.setStatus(Status.AE);
								}else if(s.equals(m.getFramework().getString("SHEET_ONE_UE"))) {
									if(!statusSet)statusSet = true;
									else throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Multiple statuses loaded",  row.getRowNum(), 4);
									if(hasAttended)throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting status and attendance",  row.getRowNum(), 4);
									vk.setStatus(Status.UE);
								}else if(s.equals(m.getFramework().getString("SHEET_ONE_ZUS"))) {
									if(!statusSet)statusSet = true;
									else throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Multiple statuses loaded",  row.getRowNum(), 4);
									if(!hasAttended)throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting status and attendance",  row.getRowNum(), 4);
									vk.setStatus(Status.ZUSAETZLICH);
								}else if(s.equals(m.getFramework().getString("SHEET_ONE_AUSG"))) {
									if(!statusSet)statusSet = true;
									else throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Multiple statuses loaded",  row.getRowNum(), 4);
									if(hasAttended)throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting status and attendance",  row.getRowNum(), 4);
									vk.setStatus(Status.AUSGETRETEN);
								}else if(s.equals(m.getFramework().getString("SHEET_ONE_NO_STATUS"))) {
									if(!statusSet)statusSet = true;
									else throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Multiple statuses loaded",  row.getRowNum(), 4);
									if(hasAttended)throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting status and attendance",  row.getRowNum(), 4);
									vk.setStatus(Status.NONE);
								}else {
									if(s.startsWith(m.getFramework().getString("SHEET_ONE_ERS_FOR"))) {
										if(!statusSet)statusSet = true;
										else throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Multiple statuses loaded",  row.getRowNum(), 4);
										if(!hasAttended)throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting status and attendance",  row.getRowNum(), 4);
										String ersatz = s.substring(m.getFramework().getString("SHEET_ONE_ERS_FOR").length());
										vk.setStatus(Status.ERSATZ);
										vk.setErsatz(m.getVK(ersatz, cleanDatabase));
									}else if(s.startsWith(m.getFramework().getString("SHEET_ONE_ERS"))) {
										if(!statusSet)statusSet = true;
										else throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Multiple statuses loaded",  row.getRowNum(), 4);
										if(!hasAttended)throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting status and attendance",  row.getRowNum(), 4);
										vk.setStatus(Status.ERSATZ);
									}else {
										vk.setRemark(s);
									}
								}
							}
							if(!statusSet) {
								if(hasAttended) {
									vk.setStatus(Status.EINGETEILT);
								}else {
									throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "No status could be loaded",  row.getRowNum(), 4);
								}
							}
						}else continue;
					}
				}
			}
			
			if(strEL.length != listEL.size()) throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting statuses and EL information",  7, 1);
			if(strAL.length != listAL.size()) throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting statuses and AL information",  7, 3);
			if(strBus.length != listBus.size()) throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting statuses and Bus driver information",  7, 5);
			
			for(VK vk_el: listEL) {
				boolean b = false;
				for(String s: strEL) {
					if(vk_el.getStringRepresentation().equals(s)) {
						if(!b)b = true;
						else throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting statuses and EL information, " + vk_el.getStringRepresentation() + " is set multiple times as EL in the header of the Einsatzbericht",  7, 1);
					}
				}
				if(!b)throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting statuses and EL information, " + vk_el.getStringRepresentation() + " is not set as EL in the header of the Einsatzbericht",  7, 1);
			}
			
			for(VK vk_al: listAL) {
				boolean b = false;
				for(String s: strAL) {
					if(vk_al.getStringRepresentation().equals(s)) {
						if(!b)b = true;
						else throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting statuses and AL information, " + vk_al.getStringRepresentation() + " is set multiple times as AL in the header of the Einsatzbericht",  7, 3);
					}
				}
				if(!b)throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting statuses and AL information, " + vk_al.getStringRepresentation() + " is not set as AL in the header of the Einsatzbericht",  7, 3);
			}
			
			for(VK vk_bus: listBus) {
				boolean b = false;
				for(String s: strBus) {
					if(vk_bus.getStringRepresentation().equals(s)) {
						if(!b)b = true;
						else throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting statuses and Bus driver information, " + vk_bus.getStringRepresentation() + " is set multiple times as Bus driver in the header of the Einsatzbericht",  7, 3);
					}
				}
				if(!b)throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "Conflicting statuses and Bus driver information, " + vk_bus.getStringRepresentation() + " is not set as Bus driver in the header of the Einsatzbericht",  7, 3);
			}
			
			int kuerzungIdOffset = Kuerzung.getCurrId();
			
			for(int k = lastCounter + 4; !(row = sheet.getRow(k)).getCell(1).getStringCellValue()
					.equals(m.getFramework().getString("SHEET_ONE_OTHER"));k++) {
				lastCounter = k;
				if(lastCounter > 1000)throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "The file does not fit the format.",  row.getRowNum(), 1);
				
				
				String rankStr = row.getCell(1).getStringCellValue();
				String nameStr = row.getCell(2).getStringCellValue();
				if(nameStr.isEmpty() && rankStr.isEmpty())continue;
				else {
					String[] names = nameStr.split(", ");
					String vkStrRepresentation = rankStr.concat(" ").concat(names[0]).concat(" ").concat(names[1]);
					VK vk = m.getVK(vkStrRepresentation, cleanDatabase);
					if(vk == null)throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "VK " + vkStrRepresentation + "not found",  row.getRowNum(), 4);
					if(!vk.isSelected()) {
						throw new EinsatzberichtLoadingException(f.getAbsolutePath(), "The VK " + vk.getStringRepresentation() + " must be selected to get a Kuerzung",  row.getRowNum(), 2);
					}else {
						String numberStr = row.getCell(4).getStringCellValue();
						int percentage = Integer.parseInt(numberStr.substring(0, numberStr.length()-1));
						String reason = row.getCell(5).getStringCellValue();
						vk.getKuerzungsListe().add(new Kuerzung(Kuerzung.getCurrId() - kuerzungIdOffset, percentage, reason));
					}
				}
			}
					
			remark = sheet.getRow(lastCounter +3).getCell(1).getStringCellValue();
			
			for(VK vk: cleanDatabase) {
				if(vk.isSelected())selectedVK.add(vk);
			}
			
			//TODO: K�rzungen, remark
			
			this.name = name;
			this.begin = begin;
			this.end = end;
			this.remark = remark;
			this.listEL = listEL;
			this.listAL = listAL;
			this.listBus = listBus;
			this.selectedVK = selectedVK;
			
			if(wb!=null)wb.close();
		}catch(Exception ex) {
//			if(m != null && m.getLogger() != null)m.getLogger().log(Level.SEVERE, "", ex); 
//			else ex.printStackTrace();
			if(wb!=null)wb.close();
			throw ex;
		}
//		String[] strEingeteilt = row.getCell(7).getStringCellValue().split(", ");
//		String[] strErsatz = row.getCell(8).getStringCellValue().split(", ");
//		String[] strZusaetzlich = row.getCell(9).getStringCellValue().split(", ");
//		String[] strSE = row.getCell(10).getStringCellValue().split(", ");
//		String[] strAE = row.getCell(11).getStringCellValue().split(", ");
//		String[] strUE = row.getCell(12).getStringCellValue().split(", ");
//		String[] strNone = row.getCell(13).getStringCellValue().split(", ");
//		String[] kuerzung = row.getCell(14).getStringCellValue().split(", ");
//		
//		listEL = new ArrayList<>();
//		if(!wasOriginalListEmpty(strEL)) {
//			for(String s: strEL) {
//				listEL.add(m.getVK(s));
//			}
//		}
//		listAL = new ArrayList<>();
//		if(!wasOriginalListEmpty(strAL)) {
//			for(String s: strAL) {
//				listAL.add(m.getVK(s));
//			}
//		}
//		listBus = new ArrayList<>();
//		if(!wasOriginalListEmpty(strBus)) {
//			for(String s: strBus) {
//				listBus.add(m.getVK(s));
//			}
//		}
//		
//		List<VK> selectedVK = new ArrayList<VK>();
//		
//		if(!wasOriginalListEmpty(strEingeteilt)) {
//			for(String s: strEingeteilt) {
//				VK vk = m.getVK(s);
//				vk.setSelected(true);
//				vk.setStatus(Status.EINGETEILT);
//				selectedVK.add(vk);
//			}
//		}
//		if(!wasOriginalListEmpty(strErsatz)) {
//			for(String s: strErsatz) {
//				VK vk = m.getVK(s);
//				vk.setSelected(true);
//				vk.setStatus(Status.ERSATZ);
//				selectedVK.add(vk);
//			}
//		}
//		if(!wasOriginalListEmpty(strZusaetzlich)) {
//			for(String s: strZusaetzlich) {
//				VK vk = m.getVK(s);
//				vk.setSelected(true);
//				vk.setStatus(Status.ZUSAETZLICH);
//				selectedVK.add(vk);
//			}
//		}
//		if(!wasOriginalListEmpty(strSE)) {
//			for(String s: strSE) {
//				VK vk = m.getVK(s);
//				vk.setSelected(true);
//				vk.setStatus(Status.SE);
//				selectedVK.add(vk);
//			}
//		}
//		if(!wasOriginalListEmpty(strEingeteilt)) {
//			for(String s: strEingeteilt) {
//				VK vk = m.getVK(s);
//				vk.setSelected(true);
//				vk.setStatus(Status.EINGETEILT);
//				selectedVK.add(vk);
//			}
//		}
	}
	/**
	 * Sets the Status of vk with status if the statusName is equal to the read String.
	 * @param vk The VK, whose status is set
	 * @param readString The String that was read from the Einsatzbericht
	 * @param statusName The name of the Status that is checked. The actual statusName will be looked up in the Framework String dictionary
	 * @param status The status that is set
	 * @param hasAttended Represents the hasAttended column in the Einsatzreport. Used to check whether the hasAttended state conflicts the to be set status.
	 * @param filePath The filePath of the opened Einsatzbericht
	 * @param row The row of the currently read cell
	 * @param col The column of the currently read cell
	 * @return if the status was set
	 * @throws EinsatzberichtLoadingException if the Attendance state conflicts the to be set status
	 */
//	//TODO: USE THIS
//	private boolean setStatusHelper(VK vk, String readString, String statusName, Status status, boolean hasAttended, String filePath, int row, int col) throws EinsatzberichtLoadingException {
//		if(readString.equals(m.getFramework().getString(statusName))) {
//			if(!(status.isDemandingAttendance() ? hasAttended : !hasAttended))throw new EinsatzberichtLoadingException(filePath, "Conflicting status and attendance",  row,  col);
//			vk.setStatus(status);
//			return true;
//		}
//		return false;
//	}
	/**
	 * Initializes a Einsatzbericht. 
	 * @param m The instance of the Main class used
	 * @param version The version of the database
	 * @param name The name of the Einsatz
	 * @param begin The date of the begin of the Einsatz
	 * @param end The date of the end of the Einsatz
	 * @param remark The remark text
	 * @param selectedVK The list of all VKs selected
	 * @param listEL The list of all ELs
	 * @param listAL The list of all ALs
	 * @param listBus The list of all drivers
	 */
	public Einsatzbericht(Main m, String version, String name, Date begin, Date end, String remark, List<VK> selectedVK, List<VK> listEL, List<VK> listAL, List<VK> listBus) {
		this.m = m;
		Collections.sort(listEL, Main.VK_DEFAULT_COMPARATOR_CHAIN_IGNORING_GROUPS);
		Collections.sort(listAL, Main.VK_DEFAULT_COMPARATOR_CHAIN_IGNORING_GROUPS);
		Collections.sort(listBus, Main.VK_DEFAULT_COMPARATOR_CHAIN_IGNORING_GROUPS);
		Collections.sort(selectedVK, Main.VK_DEFAULT_COMPARATOR_CHAIN_IGNORING_GROUPS);
		this.name = name;
		this.selectedVK = selectedVK;
		this.listEL = listEL;
		this.listAL = listAL;
		this.listBus = listBus;
		this.begin = begin;
		this.end = end;
		this.creationOfReport = new Date(System.currentTimeMillis());
		this.remark = remark;
		this.version = version;
	}
	
	public void createEinsatzbericht(boolean isBussePutzenReport) throws IOException{
		String exportPath = m.settings.getExportPath() + "/" +
	    		new SimpleDateFormat("yyyy").format(begin) + "_"
	    		+ new SimpleDateFormat("MM").format(begin) + "_"
	    		+ new SimpleDateFormat("dd").format(begin) + "_";
		if(isBussePutzenReport)exportPath += "BP_";
		
		exportPath += name.replaceAll("[ ]", "_")
	    		+ ".xls";
		
		m.getLogger().log(Level.FINE, "Creating Einsatzbericht at " + Paths.get(exportPath).toAbsolutePath().toString());
		List<VK> listSelected = new ArrayList<VK>();
	    listSelected.addAll(selectedVK);
//	    listSelected.addAll(listEL);
//	    listSelected.addAll(listAL);
//	    listSelected.addAll(listBus);
	
	    /*
	     *	First sheet of a Busse Putzen report is the same as the sheet of a regular report. 
	     */
	    
		HSSFWorkbook wb = new HSSFWorkbook();
	    //Workbook wb = new XSSFWorkbook();
	    CreationHelper createHelper = wb.getCreationHelper();
	    Sheet sheet = wb.createSheet(m.getFramework().getString("SHEET_ONE"));
	    sheet.setDefaultRowHeight((short) (15*20));
	    // Create a row and put some cells in it. Rows are 0 based.
	    
	    CellStyle cellStyle;
	    
	    HSSFFont defaultFont= wb.createFont();
	    defaultFont.setFontHeightInPoints((short)10);
	    defaultFont.setFontName("Cambria");
	    defaultFont.setColor(IndexedColors.BLACK.getIndex());
	    defaultFont.setBold(false);
	    defaultFont.setItalic(false);
	    
	    HSSFFont headingFont= wb.createFont();
	    headingFont.setFontHeightInPoints((short)16);
	    headingFont.setFontName("Arial");
	    headingFont.setColor(IndexedColors.BLACK.getIndex());
	    headingFont.setBold(true);
	    headingFont.setItalic(false);
	    
	    
	    HSSFFont subHeadingFont= wb.createFont();
	    subHeadingFont.setFontHeightInPoints((short)16);
	    subHeadingFont.setFontName("Arial");
	    subHeadingFont.setColor(IndexedColors.BLACK.getIndex());
	    subHeadingFont.setBold(false);
	    subHeadingFont.setItalic(false);
	    
	    HSSFFont mainFont= wb.createFont();
	    mainFont.setFontHeightInPoints((short)10);
	    mainFont.setFontName("Arial");
	    mainFont.setColor(IndexedColors.BLACK.getIndex());
	    mainFont.setBold(true);
	    mainFont.setItalic(false);
	    
	    //ROW 2
	    Row row = sheet.createRow(1);
	    sheet.addMergedRegion(new CellRangeAddress(1, 2, 1, 6));
	    
	    cellStyle = getNewBorderedCellStyle(wb, true, true, true, true);
	    cellStyle.setFont(headingFont);
	    cellStyle.setAlignment(HorizontalAlignment.CENTER);
	    cellStyle.setVerticalAlignment(VerticalAlignment.CENTER);
	    
	    for(int i = 2; i<7; i++){
		    row.createCell(i).setCellStyle(cellStyle);
	    }
	    Cell cell = row.createCell(1);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_TITLE"));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    row = sheet.createRow(2);
	    
	    for(int i = 1; i< 7; i++){
    		row.createCell(i).setCellStyle(cellStyle);
	    }
	    
	    //ROW 5
	    row = sheet.createRow(4);
	    cellStyle = getNewBorderedCellStyle(wb, true, true, true, false);
	    cellStyle.setFont(mainFont);
	    
	    for(int i = 2; i < 5; i++)row.createCell(i).setCellStyle(cellStyle);
	    
	    cell = row.createCell(1);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_EINSATZBEZ"));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(5);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_BEGIN"));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);

	    cell = row.createCell(6);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_END"));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    //ROW 6
	    row = sheet.createRow(5);
	    cellStyle = getNewBorderedCellStyle(wb, false, true, true, true);
	    
	    for(int i = 2; i < 5; i++)row.createCell(i).setCellStyle(cellStyle);
	    		    		    
	    cell = row.createCell(1);
	    cell.setCellValue(this.name);
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    
	    cellStyle = getNewBorderedCellStyle(wb, false, true, true, true);
	    
	    cell = row.createCell(5);
	    cell.setCellValue(m.settings.getDateFormat().format(this.begin));
	    lockCell(cell, wb);
	    cellStyle.setDataFormat(
	    		createHelper.createDataFormat().getFormat(m.settings.getDateFormatExcel()));
	    cell.setCellStyle(cellStyle);
	    		    
	    cell = row.createCell(6);
	    cell.setCellValue(m.settings.getDateFormat().format(this.end));
	    lockCell(cell, wb);
	    cellStyle.setDataFormat(
	    		createHelper.createDataFormat().getFormat(m.settings.getDateFormatExcel()));
	    cell.setCellStyle(cellStyle);
	    
	    sheet.addMergedRegion(new CellRangeAddress(4, 4, 1, 4));
	    sheet.addMergedRegion(new CellRangeAddress(5, 5, 1, 4));
	    
	    //ROW 7
	    row = sheet.createRow(6);
	    cellStyle = getNewBorderedCellStyle(wb, true, true, true, false);
	    cellStyle.setFont(mainFont);
	    		    
	    for(int i = 2; i < 5; i++)row.createCell(i).setCellStyle(cellStyle);
	    		    
	    cell = row.createCell(1);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_EL"));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(3);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_AL"));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(5);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_BUS"));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(6);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_DATE_OF_CREATION"));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    //ROW 8
	    row = sheet.createRow(7);
	    cellStyle = getNewBorderedCellStyle(wb, false, true, true, true);
	    
	    for(int i = 2; i < 5; i++)row.createCell(i).setCellStyle(cellStyle);
	    
	    
	    
	    cell = row.createCell(1);
	    cell.setCellValue(m.getStringFromVKList(this.listEL));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(3);
	    cell.setCellValue(m.getStringFromVKList(this.listAL));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(5);
	    cell.setCellValue(m.getStringFromVKList(this.listBus));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cellStyle = getNewBorderedCellStyle(wb, false, true, true, true);
	    cell = row.createCell(6);
	    cellStyle.setDataFormat(
	    		createHelper.createDataFormat().getFormat(m.settings.getDateFormatExcel()));
	    cell.setCellStyle(cellStyle);
	    cell.setCellValue(creationOfReport);
	    CellUtil.setAlignment(cell, HorizontalAlignment.LEFT);
	    lockCell(cell, wb);
	    
	    
	    sheet.addMergedRegion(new CellRangeAddress(6, 6, 1, 2));
	    sheet.addMergedRegion(new CellRangeAddress(6, 6, 3, 4));

	    sheet.addMergedRegion(new CellRangeAddress(7, 7, 1, 2));
	    sheet.addMergedRegion(new CellRangeAddress(7, 7, 3, 4));
	    
	    int tableSectionOne = 8;
	    //ROW 10
	    row = sheet.createRow(tableSectionOne);
	    cellStyle = wb.createCellStyle();
	    
	    cell = row.createCell(1);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_ASSIGNED_VKS"));
	    lockCell(cell, wb);
	    
	    cellStyle.setAlignment(HorizontalAlignment.CENTER);
	    cellStyle.setVerticalAlignment(VerticalAlignment.CENTER);
	    cellStyle.setFont(subHeadingFont);
	    cell.setCellStyle(cellStyle);
	    
	    sheet.addMergedRegion(new CellRangeAddress(tableSectionOne, tableSectionOne+1, 1, 6));
	    sheet.addMergedRegion(new CellRangeAddress(tableSectionOne+2, tableSectionOne+2, 2, 3));
	    sheet.addMergedRegion(new CellRangeAddress(tableSectionOne+2, tableSectionOne+2, 5, 6));
	   
	    //ROW 12
	    int buff1 = createTable(sheet, 1, tableSectionOne+2, getNewBorderedCellStyle(wb, true, true, true, true), wb);
	    int tableSectionTwo = tableSectionOne + buff1 + 2 /*header*/;
	    //ROW buff1+13
	    row = sheet.createRow(tableSectionTwo);
	    cellStyle = wb.createCellStyle();
	    
	    cell = row.createCell(1);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_KUERZUNG"));
	    lockCell(cell, wb);
	    
	    cellStyle.setAlignment(HorizontalAlignment.CENTER);
	    cellStyle.setVerticalAlignment(VerticalAlignment.CENTER);
	    cellStyle.setFont(subHeadingFont);
	    cell.setCellStyle(cellStyle);
	    
	    sheet.addMergedRegion(new CellRangeAddress(tableSectionTwo, tableSectionTwo+1, 1, 6));
	    sheet.addMergedRegion(new CellRangeAddress(tableSectionTwo+2, tableSectionTwo+2, 2, 3));
	    sheet.addMergedRegion(new CellRangeAddress(tableSectionTwo+2, tableSectionTwo+2, 5, 6));
	    
	    //ROW buff1+14
	    int buff2 = createTable2(sheet, 1, tableSectionTwo+2, getNewBorderedCellStyle(wb, true, true, true, true), wb);
	    int tableSectionThree = tableSectionTwo + buff2 + 2 /*header*/;
	    
	    row = sheet.createRow(tableSectionThree);
	    cellStyle = wb.createCellStyle();
	    
	    cell = row.createCell(1);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_OTHER"));
	    lockCell(cell, wb);
	    
	    cellStyle.setAlignment(HorizontalAlignment.CENTER);
	    cellStyle.setVerticalAlignment(VerticalAlignment.CENTER);
	    cellStyle.setFont(subHeadingFont);
	    cell.setCellStyle(cellStyle);
	    
	    sheet.addMergedRegion(new CellRangeAddress(tableSectionThree, tableSectionThree+1, 1, 6));
	    
	    cellStyle = getNewBorderedCellStyle(wb, true, true, true, true);
	    
	    row = sheet.createRow(tableSectionThree+2);
	    
//	    HSSFCellStyle style = wb.createCellStyle();
        cellStyle.setWrapText(true);
//        row.setRowStyle(style);
        
	    cell = row.createCell(1);
	    cell.setCellValue(remark);
	    cell.setCellStyle(cellStyle);
	    CellUtil.setAlignment(cell, HorizontalAlignment.JUSTIFY);
	    CellUtil.setVerticalAlignment(cell, VerticalAlignment.TOP);
	   
	    int heightOfRemarkBox = 25;
	    
	    for(int i = 2; i < 7; i++){
	    	cell = row.createCell(i);
	    	cell.setCellStyle(cellStyle);
	    }
	    
	    for(int i = 3; i < 3+heightOfRemarkBox; i++){
		    row = sheet.createRow(tableSectionThree + i);
	    	for(int k = 1; k < 7; k++){
		    	cell = row.createCell(k);
		    	cell.setCellStyle(cellStyle);
		    }
	    }
	    
	    sheet.addMergedRegion(new CellRangeAddress(tableSectionThree+2, tableSectionThree+2+heightOfRemarkBox, 1, 6));
	    
	    for(int i = 0; i < 5; i++)sheet.setColumnWidth(i, Math.round(256*BASE_COLUMN_WIDTH));
	    sheet.setColumnWidth(5, Math.round(256*BASE_COLUMN_WIDTH*2));
	    sheet.setColumnWidth(6, Math.round(256*BASE_COLUMN_WIDTH*2));
	    sheet.setColumnWidth(7, Math.round(256*BASE_COLUMN_WIDTH));
	    
	    //SHEET TWO
	    
	    sheet = wb.createSheet(m.getFramework().getString("SHEET_TWO"));
	    
	    
//	    Early approach: Copy a Base64 encoded String into Excel -> prevent manipulation by the user. However, this approach was neither feasible nor necessary. 
//		    cell = row.createCell(0);
//		    String einsatzCode = generateEinsatzberichtCode();
//		    cell.setCellStyle(cellStyle);
//		    cell.setCellValue(einsatzCode);
//		    lockCell(cell, wb);
//		    row = sheet.createRow(1);
//		    
//		    
//		    
//		    cell = row.createCell(0);
//		    cell.setCellValue(Base64.getEncoder().encodeToString(einsatzCode.getBytes()));
//		    lockCell(cell, wb);
	    row = sheet.createRow(0);
	    
	    cell = row.createCell(0);
	    cell.setCellValue(name);
	    lockCell(cell, wb);
	    
	    cellStyle = wb.createCellStyle();
	    cellStyle.setDataFormat(
	    		createHelper.createDataFormat().getFormat(m.settings.getDateFormatExcel()));
	    
	    cell = row.createCell(1);
	    cell.setCellStyle(cellStyle);
	    cell.setCellValue(begin);
	    lockCell(cell, wb);
	    
	    cell = row.createCell(2);
	    cell.setCellStyle(cellStyle);
	    cell.setCellValue(end);
	    lockCell(cell, wb);
	    
	    /*
	     * Using NAND Gate:
	     * if not Busse putzen -> do not ignore
	     * if Busse putzen:
	     * 		if not ignore -> do not ignore
	     * 		if ignore -> do ignore
	     * => Only ignore, if Busse putzen AND ignore
	     */
	    
	    cell = row.createCell(4);
	    if(!(isBussePutzenReport && BP_IGNORE_EL)) cell.setCellValue(m.getStringFromVKList(listEL));
	    else cell.setCellValue(m.getStringFromVKList(new ArrayList<VK>()));
	    lockCell(cell, wb);
	    
	    cell = row.createCell(5);
	    if(!(isBussePutzenReport && BP_IGNORE_AL)) cell.setCellValue(m.getStringFromVKList(listAL));
	    else cell.setCellValue(m.getStringFromVKList(new ArrayList<VK>()));
	    lockCell(cell, wb);
	    
	    cell = row.createCell(6);
	    if(!(isBussePutzenReport && BP_IGNORE_BUS)) cell.setCellValue(m.getStringFromVKList(listBus));
	    else cell.setCellValue(m.getStringFromVKList(new ArrayList<VK>()));
	    lockCell(cell, wb);
		    
	    List<VK> listSE = new ArrayList<VK>();
	    List<VK> listAE = new ArrayList<VK>();
	    List<VK> listUE = new ArrayList<VK>();
	    List<VK> listErsatz = new ArrayList<VK>();
	    List<VK> listZusaetzlich = new ArrayList<VK>();
	    List<VK> listEingeteilt = new ArrayList<VK>();
	    List<VK> listNone = new ArrayList<VK>();
	    List<VK> listAusgetreten = new ArrayList<VK>();
	    
	    for(VK vk: listSelected){
	    	switch(vk.getStatus()){
	    	case EINGETEILT:
	    		if(!(isBussePutzenReport && BP_IGNORE_EINGETEILT)) listEingeteilt.add(vk);
	    		break;
	    	case ERSATZ:
	    		if(!(isBussePutzenReport && BP_IGNORE_ERSATZ)) listErsatz.add(vk);
	    		break;
	    	case ZUSAETZLICH:
	    		if(!(isBussePutzenReport && BP_IGNORE_ZUSAETZLICH)) listZusaetzlich.add(vk);
	    		break;
	    	case AE:
	    		if(!(isBussePutzenReport && BP_IGNORE_AE)) listAE.add(vk);
	    		break;
	    	case SE:
	    		if(!(isBussePutzenReport && BP_IGNORE_SE)) listSE.add(vk);
	    		break;
	    	case UE:
	    		if(!(isBussePutzenReport && BP_IGNORE_UE)) listUE.add(vk);
	    		break;
	    	case NONE:
	    		if(!(isBussePutzenReport && BP_IGNORE_NONE)) listNone.add(vk);
	    		break;
			case AUSGETRETEN:
				if(!(isBussePutzenReport && BP_IGNORE_AUSGETRETEN)) listAusgetreten.add(vk);
				break;
	    	}
	    }
		   
	    row.createCell(7).setCellValue(m.getStringFromVKList(listEingeteilt));
	    row.createCell(8).setCellValue(m.getStringFromVKList(listErsatz));
	    row.createCell(9).setCellValue(m.getStringFromVKList(listZusaetzlich));
	    row.createCell(10).setCellValue(m.getStringFromVKList(listSE));
	    row.createCell(11).setCellValue(m.getStringFromVKList(listAE));
	    row.createCell(12).setCellValue(m.getStringFromVKList(listUE));
	    row.createCell(13).setCellValue(m.getStringFromVKList(listNone));
		
	    StringBuilder sb = new StringBuilder();
	    for(VK vk: selectedVK){
	    	if(!vk.getKuerzungsListe().isEmpty()){
	    		if(!(isBussePutzenReport && BP_IGNORE_KUERZUNG)) sb.append(vk.getStringRepresentation() + ", ");
	    	}
	    }
	    String kuerzungsString = sb.toString();
		    
	    cell = row.createCell(14);
	    cellStyle = wb.createCellStyle();
	    cell.setCellStyle(cellStyle);
	    cell.setCellValue(kuerzungsString.isEmpty()?"--":kuerzungsString);
	    lockCell(cell, wb);
		
	    row = sheet.createRow(1);
	    
	    cell = row.createCell(0);
	    cellStyle = wb.createCellStyle();
	    cell.setCellValue("version:");
	    cell.setCellStyle(cellStyle);
	    lockCell(cell, wb);
	    
	    cell = row.createCell(1);
	    cellStyle = wb.createCellStyle();
	    cell.setCellValue(this.version);
	    cell.setCellStyle(cellStyle);
	    lockCell(cell, wb);
	    
//		    cell = row.createCell(15);
//		    cell.setCellStyle(cellStyle);
//		    cell.setCellValue("Noch nicht unterst�tzt.");
//		    lockCell(cell, wb);
	    
	    // Write the output to a file
	    FileOutputStream fileOut = new FileOutputStream(exportPath);
	    wb.write(fileOut);
	    fileOut.close();
	    
	    if(READONLY){
		    File f = new File(exportPath);
		    f.setWritable(false);
	    }
	    m.getLogger().log(Level.FINE, "Einsatzbericht created successfully. ");
	}
	private void lockCell(Cell cell, Workbook wb) {
		if(LOCKCELL){
			String s = null;
		
			FormulaEvaluator evaluator = wb.getCreationHelper().createFormulaEvaluator();
			if (cell!=null) {
			    switch (evaluator.evaluateFormulaCellEnum(cell)) {
			        case BOOLEAN:
			            s = Boolean.toString(cell.getBooleanCellValue());
			            break;
			        case NUMERIC:
			        	if (DateUtil.isCellDateFormatted(cell)) {
			        		s = cell.getDateCellValue().toString();
		        		} else {
		        			s = Double.toString(cell.getNumericCellValue());
	        			}
			        	break;
			        case STRING:
			            s = cell.getStringCellValue();
			            break;
			        case BLANK:
			            break;
			        case ERROR:
			            break;
	
			        // CELL_TYPE_FORMULA will never occur
			        case FORMULA: 
			            break;
				default:
					break;
			    }
			}
			String[] displayNameList = new String[]{s};
		    DVConstraint displayNameConstraint = DVConstraint.createExplicitListConstraint(displayNameList);
	
		    CellRangeAddressList displayNameCellRange = new CellRangeAddressList(cell.getRowIndex(),cell.getRowIndex(),cell.getColumnIndex(),cell.getColumnIndex());
	
		    HSSFDataValidation displayNameValidation = new HSSFDataValidation(displayNameCellRange,displayNameConstraint);
		    displayNameValidation.createErrorBox("Not Applicable","Cannot change the value");
		    displayNameValidation.setSuppressDropDownArrow(true);
		    cell.getSheet().addValidationData(displayNameValidation);
		}
	}
	/*
	private static final String FLAG_START = "[VK]";
	private static final String ENTRY_START = "{";
	private static final String ENTRY_END = "}";
	private static final String DIVIDER_PROPERTIES = ";";
	private static final String DIVIDER_ENTRIES = ";";
	private static final String ALLOCATOR = "?=";
	private static final String FLAG_NAME = "name";
	private static final String FLAG_DATE_BEGIN = "date_begin";
	private static final String FLAG_DATE_END = "date_end";
	private static final String FLAG_DATE_CREATION = "date_creation";
	private static final String FLAG_VK_SELECTED = "vk_sel";
	private static final String SAFE_STRING = "#";
	private String generateEinsatzberichtCode() {
		StringBuilder sb = new StringBuilder();
		sb.append(FLAG_START);
		sb.append(ENTRY_START);
		
		//first entry
		sb.append(FLAG_NAME);
		sb.append(ALLOCATOR);
		sb.append(ENTRY_START);
		sb.append(makeStringSafe(name));
		sb.append(ENTRY_END);
		sb.append(DIVIDER_ENTRIES);
		
		//second entry
		sb.append(FLAG_DATE_BEGIN);
		sb.append(ALLOCATOR);
		sb.append(ENTRY_START);
		sb.append(makeStringSafe(Main.DATE_FORMAT.format(begin)));
		sb.append(ENTRY_END);
		sb.append(DIVIDER_ENTRIES);
		
		//third entry
		sb.append(FLAG_DATE_END);
		sb.append(ALLOCATOR);
		sb.append(ENTRY_START);
		sb.append(makeStringSafe(Main.DATE_FORMAT.format(end)));
		sb.append(ENTRY_END);
		sb.append(DIVIDER_ENTRIES);
		
		//fourth entry
		sb.append(FLAG_DATE_CREATION);
		sb.append(ALLOCATOR);
		sb.append(ENTRY_START);
		sb.append(makeStringSafe(Main.DATE_FORMAT.format(creationOfReport)));
		sb.append(ENTRY_END);
		sb.append(DIVIDER_ENTRIES);
		
		//fifth entry
		sb.append(FLAG_VK_SELECTED);
		sb.append(ALLOCATOR);
		sb.append(ENTRY_START);
		for(VK vk: listEL){
			String s = "";
			s += ENTRY_START;
			s += makeStringSafe(Rank.getRankString(vk.getRank()));
			s += DIVIDER_PROPERTIES;
			s += makeStringSafe(vk.getName());
			s += DIVIDER_PROPERTIES;
			s += makeStringSafe(vk.getSurname());
			s += DIVIDER_PROPERTIES;
			s += makeStringSafe(vk.hasAttendedEinsatz()?"X":"--");
			s += DIVIDER_PROPERTIES;
			s += makeStringSafe("Einsatzleiter, ");
			s += makeStringSafe(vk.getRemark());
			s += ENTRY_END;
			s += DIVIDER_ENTRIES;
			sb.append(s);
		}
		
		
		for(VK vk: listAL){
			String s = "";
			s += ENTRY_START;
			s += makeStringSafe(Rank.getRankString(vk.getRank()));
			s += DIVIDER_PROPERTIES;
			s += makeStringSafe(vk.getName());
			s += DIVIDER_PROPERTIES;
			s += makeStringSafe(vk.getSurname());
			s += DIVIDER_PROPERTIES;
			s += makeStringSafe(vk.hasAttendedEinsatz()?"X":"--");
			s += DIVIDER_PROPERTIES;
			s += makeStringSafe("Abschnittsleiter, ");
			s += makeStringSafe(vk.getRemark());
			s += ENTRY_END;
			s += DIVIDER_ENTRIES;
			sb.append(s);
		}
		for(VK vk: selectedVK){
			String s = "";
			s += ENTRY_START;
			s += makeStringSafe(Rank.getRankString(vk.getRank()));
			s += DIVIDER_PROPERTIES;
			s += makeStringSafe(vk.getName());
			s += DIVIDER_PROPERTIES;
			s += makeStringSafe(vk.getSurname());
			s += DIVIDER_PROPERTIES;
			s += makeStringSafe(vk.hasAttendedEinsatz()?"X":"--");
			s += DIVIDER_PROPERTIES;
			if(listBus.contains(vk))s+=makeStringSafe("Busfahrer, ");
			s += makeStringSafe(vk.getRemark());
			s += ENTRY_END;
			s += DIVIDER_ENTRIES;
			sb.append(s);
		}
		sb.append(ENTRY_END);
		sb.append(DIVIDER_ENTRIES);
		sb.append(ENTRY_END);
		sb.append(DIVIDER_ENTRIES);
		return sb.toString();
	}
	
	private static String makeStringSafe(String string) {
		for(int i = 0; i < string.length(); i++){
			switch(string.charAt(i)){
			case '#':
			case ';':
			case '{':
			case '}':
			case '?':
			case '=':
			case '[':
			case ']':
				string = string.substring(0, i) + SAFE_STRING + string.substring(i);
				i++;
				break;
			}
		}
		return string;
	}
	*/
	private int createTable(Sheet sheet, int x, int y, CellStyle cellStyle, Workbook wb){
		//HEADING
		Row row = sheet.createRow(y);
		Cell cell;
		
	    cellStyle.setAlignment(HorizontalAlignment.CENTER);
	    cellStyle.setVerticalAlignment(VerticalAlignment.CENTER);
	    
	    cell = row.createCell(x);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_RANK"));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(x+1);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_NAME"));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(x+2);
	    cell.setCellStyle(cellStyle);
	    lockCell(cell, wb);
	    cell = row.createCell(x+5);
	    cell.setCellStyle(cellStyle);
	    lockCell(cell, wb);
	    
	    cell = row.createCell(x+4);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_REMARKS"));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(x+3);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_ATTENDED"));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    //ACTUAL CONTENT:
	    List<VK> selectedVKCopy = new ArrayList<VK>();
	    selectedVKCopy.addAll(selectedVK);
	    for(VK vk: listEL){
	    	selectedVKCopy.remove(vk);
	    }
	    for(VK vk: listAL){
	    	selectedVKCopy.remove(vk);
	    }
	    List<VK> selectedVKSection1 = new ArrayList<VK>();
	    List<VK> selectedVKSection2 = new ArrayList<VK>();
	    for(VK vk: selectedVKCopy){
	    	switch(vk.getStatus()){
	    	case EINGETEILT:
	    	case SE:
	    	case AE:
	    	case UE:
	    		selectedVKSection1.add(vk);
	    		break;
	    	case ERSATZ:
	    	case ZUSAETZLICH:
	    	case NONE:
	    	case AUSGETRETEN:
	    		selectedVKSection2.add(vk);
	    		break;
	    	}
	    }
	    
	    int buff = 1;
	    if(!listEL.isEmpty()){
	    	for(int i = 0; i < listEL.size(); i++){
		    	createTableRow(listEL.get(i), x, y+buff+i, sheet, cellStyle, wb);
		    }
	    	buff += listEL.size();
	    	createEmptyTableRow(x, y+buff, sheet, cellStyle, wb);
	    	buff++;
		}
	    if(!listAL.isEmpty()){
	    	for(int i = 0; i < listAL.size(); i++){
		    	createTableRow(listAL.get(i), x, y+buff+i, sheet, cellStyle, wb);
		    }
	    	buff += listAL.size();
	    	createEmptyTableRow(x, y+buff, sheet, cellStyle, wb);
	    	buff++;
	    }
	    
	    
	    for(int i = 0; i < selectedVKSection1.size(); i++){
	    	createTableRow(selectedVKSection1.get(i), x, y+buff+i, sheet, cellStyle, wb);
	    }
	    buff += selectedVKSection1.size();
	    createEmptyTableRow(x, y+buff, sheet, cellStyle, wb);
    	buff++;
    	
	    if(!selectedVKSection2.isEmpty()){
	    	for(int i = 0; i < selectedVKSection2.size(); i++){
	    	createTableRow(selectedVKSection2.get(i), x, y+buff+i, sheet, cellStyle, wb);
	    	}
	    	buff += selectedVKSection2.size();
	    	createEmptyTableRow(x, y+buff, sheet, cellStyle, wb);
	    	buff++;
	    	
	    }
	    return buff;
	}
	private int createTable2(Sheet sheet, int x, int y, CellStyle cellStyle, Workbook wb){
		//HEADING
		Row row = sheet.createRow(y);
		Cell cell;
		
	    cellStyle.setAlignment(HorizontalAlignment.CENTER);
	    cellStyle.setVerticalAlignment(VerticalAlignment.CENTER);
	    
	    cell = row.createCell(x);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_RANK"));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(x+1);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_NAME"));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(x+2);
	    cell.setCellStyle(cellStyle);
	    lockCell(cell, wb);
	    cell = row.createCell(x+5);
	    cell.setCellStyle(cellStyle);
	    lockCell(cell, wb);
	    
	    cell = row.createCell(x+4);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_REASON"));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(x+3);
	    cell.setCellValue(m.getFramework().getString("SHEET_ONE_PERCENTAGE"));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    //ACTUAL CONTENT:
	    List<Object[]> listKuerzung = new ArrayList<Object[]>();
	    for(VK vk: selectedVK){
	    	if(!vk.getKuerzungsListe().isEmpty()){
	    		for(int i = 0; i < vk.getKuerzungsListe().size(); i++){
	    			listKuerzung.add(new Object[]{vk, vk.getKuerzungsListe().get(i)});
	    		}
	    	}
	    }
	    int buff = 1;
	    if(listKuerzung.isEmpty()){
	    	for(int i = 0; i < 3; i++){
	    		createEmptyTableRow(x, y+buff, sheet, cellStyle, wb);
	    		buff++;
	    	}
	    }else{
	    	for(int i = 0; i < listKuerzung.size(); i++){
	    		createTableRow2((VK) listKuerzung.get(i)[0], (Kuerzung) listKuerzung.get(i)[1], x, y+buff, sheet, cellStyle, wb);
	    		buff++;
	    	}
	    }
	    
	    return buff;
	    
	}
	
	private void createTableRow(VK vk, int x, int y, Sheet sheet, CellStyle cellStyle, Workbook wb){
		Row row = sheet.createRow(y);
		Cell cell;
	    
	    cell = row.createCell(x);
	    cell.setCellValue(
	    		Main.getRankString(
	    				vk.getRank()));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(x+1);
	    cell.setCellValue(vk.getName() + ", " + vk.getSurname());
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(x+2);
	    cell.setCellStyle(cellStyle);
	    lockCell(cell, wb);
	    row.createCell(x+5).setCellStyle(cellStyle);
	    
	    cell = row.createCell(x+4);
	    String s = "";
	    if(listEL.contains(vk))s+= m.getFramework().getString("SHEET_ONE_EL") + ", ";
	    if(listAL.contains(vk))s+=m.getFramework().getString("SHEET_ONE_AL") + ", ";
	    if(listBus.contains(vk))s+=m.getFramework().getString("SHEET_ONE_BUS") + ", ";
	    switch(vk.getStatus()){
	    case SE:
	    	s += m.getFramework().getString("SHEET_ONE_SE") + ", ";
	    	break;
	    case AE:
	    	s += m.getFramework().getString("SHEET_ONE_AE") + ", ";
	    	break;
	    case UE:
	    	s += m.getFramework().getString("SHEET_ONE_UE") + ", ";
	    	break;
	    case ZUSAETZLICH:
	    	s+= m.getFramework().getString("SHEET_ONE_ZUS") + ", ";
	    	break;
	    case EINGETEILT:
	    	break;
	    case AUSGETRETEN:
	    	s+= m.getFramework().getString("SHEET_ONE_AUSG") + ", ";
	    	break;
	    case ERSATZ:
	    	if(vk.getErsatz() != null)
	    		s+= m.getFramework().getString("SHEET_ONE_ERS_FOR") + vk.getErsatz().getStringRepresentation() + ", ";
	    	else s+= m.getFramework().getString("SHEET_ONE_ERS") + ", ";
	    	break;
	    case NONE:
	    	s+= m.getFramework().getString("SHEET_ONE_NO_STATUS");
	    	break;
	    }
	    cell.setCellValue(s + vk.getRemark());
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(x+3);
	    cell.setCellValue(vk.hasAttendedEinsatz()
	    		? m.getFramework().getString("SHEET_ONE_ATTENDED_TRUE") : m.getFramework().getString("SHEET_ONE_ATTENDED_FALSE"));
	    lockCell(cell, wb);
	   
	    cell.setCellStyle(cellStyle);
	    
	    sheet.addMergedRegion(new CellRangeAddress(y, y, x+1, x+2));
	    sheet.addMergedRegion(new CellRangeAddress(y, y, x+4, x+5));
	}
	private void createTableRow2(VK vk, Kuerzung k, int x, int y, Sheet sheet, CellStyle cellStyle, Workbook wb){
		Row row = sheet.createRow(y);
		Cell cell;
	    
	    cell = row.createCell(x);
	    cell.setCellValue(
	    		Main.getRankString(
	    				vk.getRank()));
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(x+1);
	    cell.setCellValue(vk.getName() + ", " + vk.getSurname());
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(x+2);
	    cell.setCellStyle(cellStyle);
	    lockCell(cell, wb);
	    row.createCell(x+5).setCellStyle(cellStyle);
	    
	    cell = row.createCell(x+4);
	    cell.setCellValue(k.getReason());
	    lockCell(cell, wb);
	    cell.setCellStyle(cellStyle);
	    
	    cell = row.createCell(x+3);
	    cell.setCellValue(k.getPercentage() + "%");
	    lockCell(cell, wb);
	   
	    cell.setCellStyle(cellStyle);
	    
	    sheet.addMergedRegion(new CellRangeAddress(y, y, x+1, x+2));
	    sheet.addMergedRegion(new CellRangeAddress(y, y, x+4, x+5));
	}
	private void createEmptyTableRow(int x, int y, Sheet sheet, CellStyle cellStyle, Workbook wb){
		Row row = sheet.createRow(y);
		Cell cell;
		for(int i = 0; i < 6; i++){
			cell = row.createCell(x+i);
			cell.setCellStyle(cellStyle);
			lockCell(cell, wb);
		}
	       
	    sheet.addMergedRegion(new CellRangeAddress(y, y, x+1, x+2));
	    sheet.addMergedRegion(new CellRangeAddress(y, y, x+4, x+5));
	}
	
	private CellStyle getNewBorderedCellStyle(Workbook wb, boolean top, boolean left, boolean right, boolean bottom){
		CellStyle cellStyle = wb.createCellStyle();
		if(top){
			cellStyle.setBorderTop(BorderStyle.THIN);
			cellStyle.setTopBorderColor(IndexedColors.BLACK.getIndex());
		}
		if(bottom){
			cellStyle.setBorderBottom(BorderStyle.THIN);
			cellStyle.setBottomBorderColor(IndexedColors.BLACK.getIndex());
		}
		if(left){
			cellStyle.setBorderLeft(BorderStyle.THIN);
	    	cellStyle.setLeftBorderColor(IndexedColors.BLACK.getIndex());
		}
		if(right){
			cellStyle.setBorderRight(BorderStyle.THIN);
			cellStyle.setRightBorderColor(IndexedColors.BLACK.getIndex());
		}
		return cellStyle;
	}
	
	public String getName() {
		return name;
	}
	public Date getBegin() {
		return begin;
	}
	public Date getEnd() {
		return end;
	}
	public List<VK> getListEL() {
		return listEL;
	}
	public List<VK> getListAL() {
		return listAL;
	}
	public List<VK> getListBus() {
		return listBus;
	}
	public String getRemark() {
		return remark;
	}
	public List<VK> getSelectedVK() {
		return selectedVK;
	}
	public String getVersion() {
		return version;
	}
}
